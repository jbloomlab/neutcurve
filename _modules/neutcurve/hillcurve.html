<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>neutcurve.hillcurve &#8212; neutcurve 2.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b76e3c8a" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=c878986b" />
    <script src="../../_static/documentation_options.js?v=20623aea"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for neutcurve.hillcurve</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">==================</span>
<span class="sd">hillcurve</span>
<span class="sd">==================</span>

<span class="sd">Defines :class:`HillCurve` for fitting neutralization curves.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">scipy.optimize</span>


<div class="viewcode-block" id="HillCurveFittingError">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurveFittingError">[docs]</a>
<span class="k">class</span> <span class="nc">HillCurveFittingError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Error fitting a :class:`HillCurve`.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>



<div class="viewcode-block" id="HillCurve">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve">[docs]</a>
<span class="k">class</span> <span class="nc">HillCurve</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A fitted Hill curve, optionally with free baselines.</span>

<span class="sd">    Fits :math:`f\left(c\right) = b + \frac{t - b}{1 + \left(c/m\right)^s}`</span>
<span class="sd">    where :math:`f\left(c\right)` is the fraction infectivity remaining</span>
<span class="sd">    at concentration :math:`c`, :math:`m` is the midpoint</span>
<span class="sd">    of the neutralization curve, :math:`t` is the top</span>
<span class="sd">    value (e.g., 1), :math:`b` is the bottom value (e.g., 0),</span>
<span class="sd">    and :math:`s` is the slope of the curve. Because</span>
<span class="sd">    :math:`f\left(c\right)` is the fraction infectivity remaining, we expect</span>
<span class="sd">    :math:`f\left(c\right)` to get smaller as :math:`c` gets larger.</span>
<span class="sd">    This should lead us to fit :math:`s &gt; 0`.</span>

<span class="sd">    When :math:`t = 1` and :math:`b = 0`, this equation is identical to the</span>
<span class="sd">    `Hill curve &lt;https://en.wikipedia.org/wiki/Hill_equation_(biochemistry)&gt;`_,</span>
<span class="sd">    except that we are calculating the fraction **unbound** rather than</span>
<span class="sd">    the fraction bound.</span>

<span class="sd">    You may want to fit the fraction neutralized rather than the fraction</span>
<span class="sd">    infectivity. In that case, set `infectivity_or_neutralized=&#39;neutralized&#39;</span>
<span class="sd">    and then the equation that is fit will</span>
<span class="sd">    be :math:`f\left(c\right) = t + \frac{b - t}{1 + \left(c/m\right)^s}`,</span>
<span class="sd">    which means that `f\left(c\right)` gets larger rather than smaller</span>
<span class="sd">    as :math:`c` increases.</span>

<span class="sd">    Args:</span>
<span class="sd">        `cs` (array-like)</span>
<span class="sd">            Concentrations of antibody / serum.</span>
<span class="sd">        `fs` (array-like)</span>
<span class="sd">            Fraction infectivity remaining at each concentration.</span>
<span class="sd">        `infectivity_or_neutralized` ({&#39;infectivity&#39;, &#39;neutralized&#39;})</span>
<span class="sd">            Fit the fraction infectivity (:math:`f\left(c\right)` decreases as</span>
<span class="sd">            :math:`c` increases) or neutralized (:math:`f\left(c\right)`</span>
<span class="sd">            increases as :math:`c` increases). See equations above.</span>
<span class="sd">        `fix_slope_first` (bool)</span>
<span class="sd">            If True, initially fit with fixed slope, and then start from those values</span>
<span class="sd">            to re-fit all parameters including slope.</span>
<span class="sd">        `fs_stderr` (`None` or array-like)</span>
<span class="sd">            If not `None`, standard errors on `fs`.</span>
<span class="sd">        `fixbottom` (`False`, float, or tuple/list of length 2)</span>
<span class="sd">            If `False`, fit bottom of curves as free parameter. If float, fix bottom of</span>
<span class="sd">            curve to that value. If length-2 array, constrain bottom to be in that range.</span>
<span class="sd">        `fixtop` (`False`, float, or tuple/list of length 2)</span>
<span class="sd">            If `False`, fit top of curves as free parameter. If float, fix top of</span>
<span class="sd">            curve to that value. If length-2 array, constrain top to be in that range.</span>
<span class="sd">        `fixslope` (`False`, float, or tuple/list of length 2)</span>
<span class="sd">            If `False`, fit slope of curves as free parameter. If float, fix slope to</span>
<span class="sd">            that value. If length-2 array, constrain slope to be in that range.</span>
<span class="sd">        `fitlogc` (bool)</span>
<span class="sd">            Do we do the actual fitting on the concentrations or log</span>
<span class="sd">            concentrations? Gives equivalent results in principle, but</span>
<span class="sd">            fitting to log concentrations may be more efficient in pratice.</span>
<span class="sd">        `use_stderr_for_fit` (bool)</span>
<span class="sd">            Do we use `fs_stderr` for the fitting, or just for plotting?</span>
<span class="sd">            Usually it is a good idea to set to `False` and **not** use</span>
<span class="sd">            for fitting if you only have a few replicates, and the standard</span>
<span class="sd">            error is often not that accurate and so will weight some</span>
<span class="sd">            points much more than others in a way that may not be</span>
<span class="sd">            justified.</span>
<span class="sd">        `init_slope` (float)</span>
<span class="sd">            Initial value of slope used in fitting. If `fixslope` is set to a single</span>
<span class="sd">            value, it overrides this parameter. If `fixslope` is set to a range,</span>
<span class="sd">            `init_slope` is adjusted up/down to be in that range.</span>
<span class="sd">        `no_curve_fit_first` (bool)</span>
<span class="sd">            Normally the method first tries to do the optimization with `curve_fit` from</span>
<span class="sd">            `scipy`, and if that fails then tries `scipy.optimize.minimize`. If you set</span>
<span class="sd">            this to `True`, it skips trying with `curve_fit`. In general, this option is</span>
<span class="sd">            for debugging by knowledgeable developers, and you should not be using it</span>
<span class="sd">            otherwise.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        `cs` (numpy array)</span>
<span class="sd">            Concentrations, sorted from low to high.</span>
<span class="sd">        `fs` (numpy array)</span>
<span class="sd">            Fraction infectivity, ordered to match sorted concentrations.</span>
<span class="sd">        `fs_stderr` (numpy array or `None`)</span>
<span class="sd">            Standard errors on `fs`.</span>
<span class="sd">        `bottom` (float)</span>
<span class="sd">            Bottom of curve, :math:`b` in equation above.</span>
<span class="sd">        `top` (float)</span>
<span class="sd">            Top of curve, :math:`t` in equation above.</span>
<span class="sd">        `midpoint` (float)</span>
<span class="sd">            Midpoint of curve, :math:`m` in equation above. Note</span>
<span class="sd">            that the midpoint may **not** be the same as the :meth:`ic50`</span>
<span class="sd">            if :math:`t \ne 1` or :math:`b \ne 0`.</span>
<span class="sd">        `midpoint_bound` (float)</span>
<span class="sd">            Midpoint if it falls within fitted concentrations, otherwise</span>
<span class="sd">            the lowest concentration if below that or upper of above it.</span>
<span class="sd">        `midpoint_bound_type` (str)</span>
<span class="sd">            Is midpoint &#39;interpolated&#39;, or an &#39;upper&#39; or &#39;lower&#39; bound.</span>
<span class="sd">        `slope` (float)</span>
<span class="sd">            Hill slope of curve, :math:`s` in equation above.</span>
<span class="sd">        `r2` (float)</span>
<span class="sd">            Coefficient of determination indicating how well the curve fits the</span>
<span class="sd">            data (https://en.wikipedia.org/wiki/Coefficient_of_determination).</span>
<span class="sd">        `rmsd` (float)</span>
<span class="sd">            Root mean square deviation of fitted to actual values (square root of mean</span>
<span class="sd">            residual).</span>
<span class="sd">        `params_stdev` (dict or `None`)</span>
<span class="sd">            If standard deviations can be estimated on the fit</span>
<span class="sd">            parameters, keyed by &#39;bottom&#39;, &#39;top&#39;, &#39;midpoint&#39;,</span>
<span class="sd">            and &#39;slope&#39; and gives standard erorr on each. Note if</span>
<span class="sd">            you have replicates we recommend fitting those separately</span>
<span class="sd">            and taking standard error rather than using fit stdev.</span>

<span class="sd">    Use the :meth:`ic50` method to get the fitted IC50.</span>
<span class="sd">    You can use :meth:`ic50_stdev` to get the estimated standard</span>
<span class="sd">    deviation on the IC50, although if you have multiple replicates</span>
<span class="sd">    you may be better off just fitting to each separately and</span>
<span class="sd">    then taking standard error of the individual IC50s.</span>

<span class="sd">    Here are some examples. First, we import the necessary modules:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; from neutcurve import HillCurve</span>
<span class="sd">        &gt;&gt;&gt; from neutcurve.colorschemes import CBPALETTE</span>

<span class="sd">    Now simulate some data:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; m = 0.03</span>
<span class="sd">        &gt;&gt;&gt; s = 1.9</span>
<span class="sd">        &gt;&gt;&gt; b = 0.1</span>
<span class="sd">        &gt;&gt;&gt; t = 1.0</span>
<span class="sd">        &gt;&gt;&gt; cs = [0.002 * 2**x for x in range(9)]</span>
<span class="sd">        &gt;&gt;&gt; fs = [HillCurve.evaluate(c, m, s, b, t) for c in cs]</span>

<span class="sd">    Now fit to these data, and confirm that the fitted values</span>
<span class="sd">    are close to the ones used for the simulation:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut = HillCurve(cs, fs, fixbottom=False)</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut.midpoint, m, atol=1e-4)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; neut.midpoint_bound == neut.midpoint</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; neut.midpoint_bound_type</span>
<span class="sd">        &#39;interpolated&#39;</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut.slope, s, atol=1e-3)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut.top, t, atol=1e-4)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut.bottom, b, atol=1e-3)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; for key, val in neut.params_stdev.items():</span>
<span class="sd">        ...     print(f&quot;{key} = {val:.2g}&quot;)</span>
<span class="sd">        midpoint = 0.062</span>
<span class="sd">        slope = 6.3</span>
<span class="sd">        top = 0</span>
<span class="sd">        bottom = 0.73</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;IC50: {neut.ic50():.3f} +/- {neut.ic50_stdev():.3f}&quot;)</span>
<span class="sd">        IC50: 0.034 +/- 0.070</span>

<span class="sd">    Since we fit the curve to simulated data where the bottom was</span>
<span class="sd">    0.1 rather than 0, the midpoint and IC50 are different. Specifically,</span>
<span class="sd">    the IC50 is larger than the midpoint as you have to go past the midpoint</span>
<span class="sd">    to get down to 0.5 fraction infectivity:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut.ic50() &gt; neut.midpoint</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut.ic50(), 0.0337, atol=1e-4)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(0.5, neut.fracinfectivity(neut.ic50()))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; neut.fracinfectivity(neut.midpoint) &gt; 0.5</span>
<span class="sd">        True</span>

<span class="sd">    Now here is an example where we constrain both the top</span>
<span class="sd">    and the bottom (to 1 and 0, respectively) and fit</span>
<span class="sd">    the curve. Now the midpoint and IC50 are the same:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; b2 = 0</span>
<span class="sd">        &gt;&gt;&gt; t2 = 1</span>
<span class="sd">        &gt;&gt;&gt; fs2 = [HillCurve.evaluate(c, m, s, b2, t2) for c in cs]</span>
<span class="sd">        &gt;&gt;&gt; neut2 = HillCurve(cs, fs2)</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut2.midpoint, m)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut2.ic50(), m)</span>
<span class="sd">        True</span>

<span class="sd">    Now let&#39;s fit to concentrations that are all **less**</span>
<span class="sd">    than the midpoint, so that we never get to complete neutralization.</span>
<span class="sd">    The estimated IC50 is unreliable, and so will be returned as `None` unless</span>
<span class="sd">    we call :meth:`ic50` with `method` set to &#39;bound&#39;:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; cs3 = [1e-4 * 2**x for x in range(7)]</span>
<span class="sd">        &gt;&gt;&gt; (cs3[-1] &lt; m)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; fs3 = [HillCurve.evaluate(c, m, s, b2, t2) for c in cs3]</span>
<span class="sd">        &gt;&gt;&gt; neut3 = HillCurve(cs3, fs3)</span>
<span class="sd">        &gt;&gt;&gt; neut3.ic50() is None</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut3.ic50(method=&#39;bound&#39;), cs3[-1])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; neut3.midpoint_bound == cs3[-1]</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; neut3.midpoint_bound_type</span>
<span class="sd">        &#39;lower&#39;</span>

<span class="sd">    Note that we can determine if the IC50 is interpolated or an upper</span>
<span class="sd">    or lower bound using :meth:`ic50_bound`, and get a nice string</span>
<span class="sd">    using :meth:`ic50_str`:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut.ic50_bound()</span>
<span class="sd">        &#39;interpolated&#39;</span>
<span class="sd">        &gt;&gt;&gt; neut3.ic50_bound()</span>
<span class="sd">        &#39;lower&#39;</span>
<span class="sd">        &gt;&gt;&gt; neut.ic50_str()</span>
<span class="sd">        &#39;0.0337&#39;</span>
<span class="sd">        &gt;&gt;&gt; neut3.ic50_str()</span>
<span class="sd">        &#39;&gt;0.0064&#39;</span>

<span class="sd">    We can use the :meth:`dataframe` method to get the measured</span>
<span class="sd">    data and fit data at selected points. First, we do this</span>
<span class="sd">    just at measured points:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut.dataframe(&#39;measured&#39;).round(3)</span>
<span class="sd">           concentration  measurement    fit  stderr</span>
<span class="sd">        0          0.002        0.995  0.995     NaN</span>
<span class="sd">        1          0.004        0.981  0.981     NaN</span>
<span class="sd">        2          0.008        0.932  0.932     NaN</span>
<span class="sd">        3          0.016        0.791  0.791     NaN</span>
<span class="sd">        4          0.032        0.522  0.522     NaN</span>
<span class="sd">        5          0.064        0.272  0.272     NaN</span>
<span class="sd">        6          0.128        0.154  0.154     NaN</span>
<span class="sd">        7          0.256        0.115  0.115     NaN</span>
<span class="sd">        8          0.512        0.104  0.104     NaN</span>

<span class="sd">    Then we add in one more point:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut.dataframe([0.6]).round(3)</span>
<span class="sd">           concentration  measurement    fit  stderr</span>
<span class="sd">        0          0.002        0.995  0.995     NaN</span>
<span class="sd">        1          0.004        0.981  0.981     NaN</span>
<span class="sd">        2          0.008        0.932  0.932     NaN</span>
<span class="sd">        3          0.016        0.791  0.791     NaN</span>
<span class="sd">        4          0.032        0.522  0.522     NaN</span>
<span class="sd">        5          0.064        0.272  0.272     NaN</span>
<span class="sd">        6          0.128        0.154  0.154     NaN</span>
<span class="sd">        7          0.256        0.115  0.115     NaN</span>
<span class="sd">        8          0.512        0.104  0.104     NaN</span>
<span class="sd">        9          0.600          NaN  0.103     NaN</span>

<span class="sd">    In reality, you&#39;d typically just call :meth:`dataframe` with</span>
<span class="sd">    the default argument of &#39;auto&#39; to get a good range to plot.</span>
<span class="sd">    This is done if we call the :meth:`HillCurve.plot` method:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; fig, ax = neut.plot()</span>

<span class="sd">    Finally, we confirm that we get the same result regardless</span>
<span class="sd">    of whether we fit using the concentrations in linear or</span>
<span class="sd">    log space:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut_linear = HillCurve(cs, fs, fitlogc=False, fixbottom=False)</span>
<span class="sd">        &gt;&gt;&gt; all(numpy.allclose(getattr(neut, attr), getattr(neut_linear, attr))</span>
<span class="sd">        ...     for attr in [&#39;top&#39;, &#39;bottom&#39;, &#39;slope&#39;, &#39;midpoint&#39;])</span>
<span class="sd">        True</span>

<span class="sd">    Demonstrate :meth:`HillCurve.icXX`:</span>

<span class="sd">    &gt;&gt;&gt; neut.icXX(0.95) is None</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; neut.icXX_str(0.95)</span>
<span class="sd">    &#39;&gt;0.512&#39;</span>
<span class="sd">    &gt;&gt;&gt; neut.icXX_bound(0.95)</span>
<span class="sd">    &#39;lower&#39;</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut.icXX(0.95, method=&#39;bound&#39;), neut.cs[-1])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; &#39;{:.4f}&#39;.format(neut.icXX(0.8), 4)</span>
<span class="sd">    &#39;0.0896&#39;</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(0.2, neut.fracinfectivity(neut.icXX(0.8)))</span>
<span class="sd">    True</span>

<span class="sd">    We can quantify the goodness of fit with :attr:`HillCurve.r2`. For these simulated</span>
<span class="sd">    data the fit is perfect (coefficient of determination of 1):</span>

<span class="sd">    &gt;&gt;&gt; round(neut.r2, 3)</span>
<span class="sd">    1.0</span>

<span class="sd">    We can also quantify the goodness of fit with :attr:`HillCurve.rmsd`:</span>
<span class="sd">    &gt;&gt;&gt; round(neut.rmsd, 3)</span>
<span class="sd">    0.0</span>

<span class="sd">    Now fit with bounds on the parameters. First, we make bounds cover the true values:</span>

<span class="sd">    &gt;&gt;&gt; neut_bounds_cover = HillCurve(</span>
<span class="sd">    ...     cs, fs, fixbottom=(0, 0.2), fixtop=(0.9, 1), fixslope=(1, 2),</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_bounds_cover.midpoint, m, atol=1e-4)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_bounds_cover.slope, s, atol=1e-3)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_bounds_cover.top, t, atol=1e-4)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_bounds_cover.bottom, b, atol=1e-3)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_cover.r2, 3)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_cover.rmsd, 3)</span>
<span class="sd">    0.0</span>

<span class="sd">    Next fit with bounds that do not cover the true parameters:</span>
<span class="sd">    &gt;&gt;&gt; neut_bounds_nocover = HillCurve(</span>
<span class="sd">    ...     cs, fs, fixbottom=(0, 0.05), fixtop=(0.9, 0.95), fixslope=(1, 1.5),</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_nocover.midpoint, 2)</span>
<span class="sd">    0.04</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_nocover.slope, 2)</span>
<span class="sd">    1.5</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_nocover.top, 2)</span>
<span class="sd">    0.95</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_nocover.bottom, 2)</span>
<span class="sd">    0.05</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_nocover.r2, 2)</span>
<span class="sd">    0.99</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_nocover.rmsd, 3)</span>
<span class="sd">    0.045</span>

<span class="sd">    Now fit with `infectivity_or_neutralized=&#39;neutralized&#39;`, which is useful</span>
<span class="sd">    when the signal **increases** rather than decreases with increasing</span>
<span class="sd">    concentration (as would be the case if measuring fraction bound rather</span>
<span class="sd">    than fraction infectivity).</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">       &gt;&gt;&gt; neut_opp = HillCurve(cs, [1 - f for f in fs],</span>
<span class="sd">       ...                      fixtop=False, fixbottom=False,</span>
<span class="sd">       ...                      infectivity_or_neutralized=&#39;neutralized&#39;)</span>
<span class="sd">       &gt;&gt;&gt; numpy.allclose(neut_opp.top, 0.9, atol=1e-3)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; numpy.allclose(neut_opp.bottom, 0, atol=1e-3)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; numpy.allclose(neut_opp.midpoint, m)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; neut_opp.ic50() &lt; neut_opp.midpoint</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; fig, ax = neut_opp.plot(ylabel=&#39;fraction neutralized&#39;)</span>

<span class="sd">    For internal testing purposes, try with `no_curve_fit_first=False`.</span>

<span class="sd">    &gt;&gt;&gt; neut_ncf = HillCurve(cs, fs, fixbottom=False, no_curve_fit_first=True)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_ncf.midpoint, m, atol=1e-4)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_ncf.slope, s, atol=5e-3)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_ncf.top, t, atol=1e-4)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_ncf.bottom, b, atol=1e-3)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; neut_bounds_cover_ncf = HillCurve(</span>
<span class="sd">    ...     cs,</span>
<span class="sd">    ...     fs,</span>
<span class="sd">    ...     fixbottom=(0, 0.2),</span>
<span class="sd">    ...     fixtop=(0.9, 1),</span>
<span class="sd">    ...     fixslope=(1, 2),</span>
<span class="sd">    ...     no_curve_fit_first=True,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_bounds_cover_ncf.midpoint, m, atol=1e-4)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_bounds_cover_ncf.slope, s, atol=1e-3)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_bounds_cover_ncf.top, t, atol=1e-4)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut_bounds_cover_ncf.bottom, b, atol=1e-3)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_cover_ncf.r2, 3)</span>
<span class="sd">    1.0</span>

<span class="sd">    &gt;&gt;&gt; neut_bounds_nocover_ncf = HillCurve(</span>
<span class="sd">    ...     cs,</span>
<span class="sd">    ...     fs,</span>
<span class="sd">    ...     fixbottom=(0, 0.05),</span>
<span class="sd">    ...     fixtop=(0.9, 0.95),</span>
<span class="sd">    ...     fixslope=(1, 1.5),</span>
<span class="sd">    ...     no_curve_fit_first=True,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_nocover_ncf.midpoint, 2)</span>
<span class="sd">    0.04</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_nocover_ncf.slope, 2)</span>
<span class="sd">    1.5</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_nocover_ncf.top, 2)</span>
<span class="sd">    0.95</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_nocover_ncf.bottom, 2)</span>
<span class="sd">    0.05</span>
<span class="sd">    &gt;&gt;&gt; round(neut_bounds_nocover_ncf.r2, 2)</span>
<span class="sd">    0.99</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cs</span><span class="p">,</span>
        <span class="n">fs</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">infectivity_or_neutralized</span><span class="o">=</span><span class="s2">&quot;infectivity&quot;</span><span class="p">,</span>
        <span class="n">fix_slope_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">fs_stderr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fixbottom</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">fixtop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">fixslope</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">fitlogc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_stderr_for_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">init_slope</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
        <span class="n">no_curve_fit_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See main class docstring.&quot;&quot;&quot;</span>
        <span class="c1"># get data into arrays sorted by concentration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fs_stderr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fs_stderr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>

        <span class="k">if</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s2">&quot;infectivity&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.7</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;`f` increases with concentration, consider &quot;</span>
                    <span class="s1">&#39;`infectivity_or_neutralized=&quot;neutralized&quot;&#39;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s2">&quot;neutralized&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.7</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.3</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;`f` decreases with concentration, consider &quot;</span>
                    <span class="s1">&#39;`infectivity_or_neutralized=&quot;infectivity&quot;&#39;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid </span><span class="si">{</span><span class="n">infectivity_or_neutralized</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span> <span class="o">=</span> <span class="n">infectivity_or_neutralized</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;concentrations must all be &gt; 0</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># create initial guess of `(midpoint, slope, bottom, top)`</span>
        <span class="c1"># make initial guess for top</span>
        <span class="k">if</span> <span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">fixtop</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fixtop</span><span class="p">)</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">fixtop</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixtop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">fixtop</span> <span class="o">=</span> <span class="p">(</span><span class="n">fixtop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fixtop</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">fixtop</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">fixtop</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid </span><span class="si">{</span><span class="n">fixtop</span><span class="si">=}</span><span class="s2">: first element must be &lt; second&quot;</span><span class="p">)</span>
            <span class="n">top</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fixtop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="n">fixtop</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">assert</span> <span class="n">fixtop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">top</span> <span class="o">&lt;=</span> <span class="n">fixtop</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fixtop</span><span class="si">=}</span><span class="s2"> is not `False`, a number, or length-2 array&quot;</span><span class="p">)</span>
        <span class="c1"># make initial guess for bottom</span>
        <span class="k">if</span> <span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">fixbottom</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">)</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">fixbottom</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">fixbottom</span> <span class="o">=</span> <span class="p">(</span><span class="n">fixbottom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fixbottom</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">fixbottom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">fixbottom</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;invalid </span><span class="si">{</span><span class="n">fixbottom</span><span class="si">=}</span><span class="s2">: first element must be &lt; second&quot;</span>
                <span class="p">)</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span> <span class="n">fixbottom</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">assert</span> <span class="n">fixbottom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bottom</span> <span class="o">&lt;=</span> <span class="n">fixbottom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fixbottom</span><span class="si">=}</span><span class="s2"> is not `False`, a number, or length-2 array&quot;</span>
            <span class="p">)</span>
        <span class="c1"># make initial guess for midpoint</span>
        <span class="c1"># if midpoint guess outside range, guess outside range by amount</span>
        <span class="c1"># equal to spacing of last two points</span>
        <span class="n">midval</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;infectivity&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                <span class="s2">&quot;neutralized&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span>
            <span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&lt;=</span> <span class="n">midval</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;neutralized&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                <span class="s2">&quot;infectivity&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span>
            <span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get first index where f crosses midpoint</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># adjust initial slope if inconsistent with `fixslope`</span>
        <span class="k">if</span> <span class="n">fixslope</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">init_slope</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixslope</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">fixslope</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fixslope</span><span class="p">)</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="n">fixslope</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fixslope</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixslope</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">fixslope</span> <span class="o">=</span> <span class="p">(</span><span class="n">fixslope</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fixslope</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">fixslope</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">fixslope</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid </span><span class="si">{</span><span class="n">fixslope</span><span class="si">=}</span><span class="s2">: first element must be &lt; second&quot;</span><span class="p">)</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fixslope</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">init_slope</span><span class="p">,</span> <span class="n">fixslope</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">assert</span> <span class="n">fixslope</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">slope</span> <span class="o">&lt;=</span> <span class="n">fixslope</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">init_tup</span> <span class="o">=</span> <span class="p">(</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span>

        <span class="c1"># first try to fit using curve_fit</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">no_curve_fit_first</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;skipping curve_fit&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fix_slope_first</span><span class="p">:</span>
                <span class="n">fix_first_init_tup</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_curve</span><span class="p">(</span>
                    <span class="n">fixtop</span><span class="o">=</span><span class="n">fixtop</span><span class="p">,</span>
                    <span class="n">fixbottom</span><span class="o">=</span><span class="n">fixbottom</span><span class="p">,</span>
                    <span class="n">fitlogc</span><span class="o">=</span><span class="n">fitlogc</span><span class="p">,</span>
                    <span class="n">use_stderr_for_fit</span><span class="o">=</span><span class="n">use_stderr_for_fit</span><span class="p">,</span>
                    <span class="n">init_tup</span><span class="o">=</span><span class="n">init_tup</span><span class="p">,</span>
                    <span class="n">fixslope</span><span class="o">=</span><span class="n">slope</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fix_first_init_tup</span> <span class="o">=</span> <span class="n">init_tup</span>
            <span class="n">fit_tup</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_stdev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_curve</span><span class="p">(</span>
                <span class="n">fixtop</span><span class="o">=</span><span class="n">fixtop</span><span class="p">,</span>
                <span class="n">fixbottom</span><span class="o">=</span><span class="n">fixbottom</span><span class="p">,</span>
                <span class="n">fitlogc</span><span class="o">=</span><span class="n">fitlogc</span><span class="p">,</span>
                <span class="n">use_stderr_for_fit</span><span class="o">=</span><span class="n">use_stderr_for_fit</span><span class="p">,</span>
                <span class="n">init_tup</span><span class="o">=</span><span class="n">fix_first_init_tup</span><span class="p">,</span>
                <span class="n">fixslope</span><span class="o">=</span><span class="n">fixslope</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># A RuntimeError is raised by scipy if curve_fit fails:</span>
        <span class="c1"># https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="c1"># curve_fit failed, try using minimize</span>
            <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;TNC&quot;</span><span class="p">,</span> <span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span> <span class="s2">&quot;SLSQP&quot;</span><span class="p">,</span> <span class="s2">&quot;Powell&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">fix_slope_first</span><span class="p">:</span>
                    <span class="n">fix_first_init_tup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minimize_fit</span><span class="p">(</span>
                        <span class="n">fixtop</span><span class="o">=</span><span class="n">fixtop</span><span class="p">,</span>
                        <span class="n">fixbottom</span><span class="o">=</span><span class="n">fixbottom</span><span class="p">,</span>
                        <span class="n">fitlogc</span><span class="o">=</span><span class="n">fitlogc</span><span class="p">,</span>
                        <span class="n">use_stderr_for_fit</span><span class="o">=</span><span class="n">use_stderr_for_fit</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                        <span class="n">init_tup</span><span class="o">=</span><span class="n">init_tup</span><span class="p">,</span>
                        <span class="n">fixslope</span><span class="o">=</span><span class="n">slope</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">fix_first_init_tup</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fix_first_init_tup</span> <span class="o">=</span> <span class="n">init_tup</span>
                <span class="n">fit_tup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minimize_fit</span><span class="p">(</span>
                    <span class="n">fixtop</span><span class="o">=</span><span class="n">fixtop</span><span class="p">,</span>
                    <span class="n">fixbottom</span><span class="o">=</span><span class="n">fixbottom</span><span class="p">,</span>
                    <span class="n">fitlogc</span><span class="o">=</span><span class="n">fitlogc</span><span class="p">,</span>
                    <span class="n">use_stderr_for_fit</span><span class="o">=</span><span class="n">use_stderr_for_fit</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                    <span class="n">init_tup</span><span class="o">=</span><span class="n">fix_first_init_tup</span><span class="p">,</span>
                    <span class="n">fixslope</span><span class="o">=</span><span class="n">fixslope</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params_stdev</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># can&#39;t estimate errors</span>
                <span class="k">if</span> <span class="n">fit_tup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">HillCurveFittingError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fit failed:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="si">=}</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s2">&quot;midpoint&quot;</span><span class="p">,</span> <span class="s2">&quot;slope&quot;</span><span class="p">,</span> <span class="s2">&quot;bottom&quot;</span><span class="p">,</span> <span class="s2">&quot;top&quot;</span><span class="p">]):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">fit_tup</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># debugging check</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">fixval</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;slope&quot;</span><span class="p">,</span> <span class="n">fixslope</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="n">fixtop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;bottom&quot;</span><span class="p">,</span> <span class="n">fixbottom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">),</span>
        <span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">fixval</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fixval</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">fixval</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fixval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fixval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">fixval</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fix</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">fixval</span><span class="si">}</span><span class="s2">, but final </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">midpoint_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">midpoint_bound_type</span> <span class="o">=</span> <span class="s2">&quot;interpolated&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">midpoint_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">midpoint_bound_type</span> <span class="o">=</span> <span class="s2">&quot;upper&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">midpoint_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">midpoint_bound_type</span> <span class="o">=</span> <span class="s2">&quot;lower&quot;</span>

        <span class="c1"># compute coefficient of determination</span>
        <span class="c1"># https://en.wikipedia.org/wiki/Coefficient_of_determination</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>
        <span class="n">sstot</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ssres</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fracinfectivity</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sstot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ssres</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">r2</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">r2</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">r2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">ssres</span> <span class="o">/</span> <span class="n">sstot</span>

        <span class="c1"># compute rmsd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rmsd</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ssres</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_fit_curve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">fixtop</span><span class="p">,</span>
        <span class="n">fixbottom</span><span class="p">,</span>
        <span class="n">fitlogc</span><span class="p">,</span>
        <span class="n">use_stderr_for_fit</span><span class="p">,</span>
        <span class="n">init_tup</span><span class="p">,</span>
        <span class="n">fixslope</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;curve_fit, return `(midpoint, slope, bottom, top), params_stdev`.&quot;&quot;&quot;</span>

        <span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="n">init_tup</span>

        <span class="c1"># set up function and initial guesses</span>
        <span class="k">if</span> <span class="n">fitlogc</span><span class="p">:</span>
            <span class="n">evalfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_log</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">evalfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span>

        <span class="n">top_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="n">fixtop</span>
        <span class="n">bottom_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="n">fixbottom</span>
        <span class="n">slope_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">fixslope</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="n">fixslope</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixslope</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">fixslope</span> <span class="o">==</span> <span class="n">slope</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>
                <span class="c1"># https://stackoverflow.com/a/8081580</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">bottom_bounds</span><span class="p">,</span> <span class="n">top_bounds</span><span class="p">])</span>
                <span class="p">)</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">top_bounds</span><span class="p">]))</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="n">slope</span><span class="p">,</span>
                        <span class="n">bottom</span><span class="p">,</span>
                        <span class="n">t</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">bottom</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">bottom_bounds</span><span class="p">]))</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="n">slope</span><span class="p">,</span>
                        <span class="n">b</span><span class="p">,</span>
                        <span class="n">top</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="p">([</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="n">slope</span><span class="p">,</span>
                        <span class="n">bottom</span><span class="p">,</span>
                        <span class="n">top</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">fixslope</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixslope</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixslope</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span>
                        <span class="o">*</span><span class="p">[</span>
                            <span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span>
                            <span class="n">slope_bounds</span><span class="p">,</span>
                            <span class="n">bottom_bounds</span><span class="p">,</span>
                            <span class="n">top_bounds</span><span class="p">,</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">slope_bounds</span><span class="p">,</span> <span class="n">top_bounds</span><span class="p">])</span>
                <span class="p">)</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span>
                        <span class="o">*</span><span class="p">[</span>
                            <span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span>
                            <span class="n">slope_bounds</span><span class="p">,</span>
                            <span class="n">bottom_bounds</span><span class="p">,</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">slope_bounds</span><span class="p">]))</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="n">s</span><span class="p">,</span>
                        <span class="n">bottom</span><span class="p">,</span>
                        <span class="n">top</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">initguess</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">lb</span> <span class="o">&lt;</span> <span class="n">ub</span> <span class="k">for</span> <span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">bounds</span>
        <span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span><span class="p">)</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span>
            <span class="n">f</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
            <span class="n">xdata</span><span class="o">=</span><span class="n">xdata</span><span class="p">,</span>
            <span class="n">ydata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">p0</span><span class="o">=</span><span class="n">initguess</span><span class="p">,</span>
            <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="k">if</span> <span class="n">use_stderr_for_fit</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">absolute_sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">maxfev</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">perr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">fitlogc</span><span class="p">:</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>

        <span class="n">midpoint</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixslope</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">params_stderr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;midpoint&quot;</span><span class="p">:</span> <span class="n">perr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;slope&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;top&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;bottom&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">params_stderr</span><span class="p">[</span><span class="s2">&quot;bottom&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">params_stderr</span><span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">params_stderr</span><span class="p">[</span><span class="s2">&quot;bottom&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">params_stderr</span><span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">params_stderr</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;midpoint&quot;</span><span class="p">:</span> <span class="n">perr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;slope&quot;</span><span class="p">:</span> <span class="n">perr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;top&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s2">&quot;bottom&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">params_stderr</span><span class="p">[</span><span class="s2">&quot;bottom&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">params_stderr</span><span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">params_stderr</span><span class="p">[</span><span class="s2">&quot;bottom&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">params_stderr</span><span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">),</span> <span class="n">params_stderr</span>

    <span class="k">def</span> <span class="nf">_minimize_fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">fixtop</span><span class="p">,</span>
        <span class="n">fixbottom</span><span class="p">,</span>
        <span class="n">fitlogc</span><span class="p">,</span>
        <span class="n">use_stderr_for_fit</span><span class="p">,</span>
        <span class="n">method</span><span class="p">,</span>
        <span class="n">init_tup</span><span class="p">,</span>
        <span class="n">fixslope</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `(midpoint, slope, bottom, top)` if succeeds or `False` if fails.&quot;&quot;&quot;</span>

        <span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="n">init_tup</span>

        <span class="c1"># set up function and initial guesses</span>
        <span class="k">if</span> <span class="n">fitlogc</span><span class="p">:</span>
            <span class="n">evalfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_log</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">evalfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>

        <span class="n">top_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="n">fixtop</span>
        <span class="n">bottom_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="n">fixbottom</span>
        <span class="n">slope_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">fixslope</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="n">fixslope</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixslope</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span> <span class="o">+</span> <span class="p">[</span><span class="n">bottom_bounds</span><span class="p">,</span> <span class="n">top_bounds</span><span class="p">]</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_bounds</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="n">slope</span><span class="p">,</span>
                        <span class="n">bottom</span><span class="p">,</span>
                        <span class="n">t</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">bottom</span><span class="p">]</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bottom_bounds</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="n">slope</span><span class="p">,</span>
                        <span class="n">b</span><span class="p">,</span>
                        <span class="n">top</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">]</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="n">slope</span><span class="p">,</span>
                        <span class="n">bottom</span><span class="p">,</span>
                        <span class="n">top</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixslope</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">fixslope</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope_bounds</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span> <span class="o">+</span> <span class="p">[</span><span class="n">bottom_bounds</span><span class="p">,</span> <span class="n">top_bounds</span><span class="p">]</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_bounds</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">]</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bottom_bounds</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">]</span>

                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span>
                        <span class="n">c</span><span class="p">,</span>
                        <span class="n">m</span><span class="p">,</span>
                        <span class="n">s</span><span class="p">,</span>
                        <span class="n">bottom</span><span class="p">,</span>
                        <span class="n">top</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">def</span> <span class="nf">min_func</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Evaluate to zero when perfect fit.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">use_stderr_for_fit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">func</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">func</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">initguess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initguess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">initguess</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">min_func</span><span class="p">,</span> <span class="n">initguess</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">fitlogc</span><span class="p">:</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>

        <span class="n">midpoint</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixslope</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">fixslope</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixslope</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span>

<div class="viewcode-block" id="HillCurve.icXX">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.icXX">[docs]</a>
    <span class="k">def</span> <span class="nf">icXX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fracneut</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;interpolate&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generalizes :meth:`HillCurve.ic50` to arbitrary frac neutralized.</span>

<span class="sd">        For instance, set `fracneut` to 0.95 if you want the IC95, the</span>
<span class="sd">        concentration where 95% is neutralized.</span>

<span class="sd">        Args:</span>
<span class="sd">            `fracneut` (float)</span>
<span class="sd">                Compute concentration at which `fracneut` of the virus</span>
<span class="sd">                is expected to be neutralized. Note that this is the</span>
<span class="sd">                expected fraction **neutralized**, not the fraction</span>
<span class="sd">                infectivity.</span>
<span class="sd">            `method` (str)</span>
<span class="sd">                Can have following values:</span>

<span class="sd">                  - &#39;interpolate&#39;: only return a number for ICXX if it</span>
<span class="sd">                    is in range of concentrations, otherwise return `None`.</span>

<span class="sd">                  - &#39;bound&#39;: if ICXX is out of range of concentrations,</span>
<span class="sd">                    return upper or lower measured concentration depending</span>
<span class="sd">                    on if ICXX is above or below range of concentrations.</span>
<span class="sd">                    Assumes infectivity decreases with concentration.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number giving ICXX or `None` (depending on value of `method`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fracinf</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">fracneut</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">&lt;</span> <span class="n">fracinf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&lt;</span> <span class="n">fracinf</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="s2">&quot;lower&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">&gt;=</span> <span class="n">fracinf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&gt;=</span> <span class="n">fracinf</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="s2">&quot;upper&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">icXX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span> <span class="o">*</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">-</span> <span class="n">fracinf</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fracinf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span>
                <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">icXX</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">icXX</span>
            <span class="k">elif</span> <span class="n">icXX</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="s2">&quot;lower&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="s2">&quot;upper&quot;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bound&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bound</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">bound</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid </span><span class="si">{</span><span class="n">bound</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;interpolate&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid </span><span class="si">{</span><span class="n">method</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="HillCurve.ic50">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.ic50">[docs]</a>
    <span class="k">def</span> <span class="nf">ic50</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;interpolate&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;IC50 value.</span>

<span class="sd">        Concentration where infectivity remaining is 0.5. Equals</span>
<span class="sd">        `midpoint` if and only if `top = 1` and `bottom = 0`. Calculated</span>
<span class="sd">        from :math:`0.5 = b + \frac{t - b}{1 + (ic50/m)^s}`, which solves to</span>
<span class="sd">        :math:`ic50 = m \times \left(\frac{t - 0.5}{0.5 - b}\right)^{1/s}`</span>

<span class="sd">        Args:</span>
<span class="sd">            `method` (str)</span>
<span class="sd">                Can have following values:</span>

<span class="sd">                  - &#39;interpolate&#39;: only return a number for IC50 if it</span>
<span class="sd">                    is in range of concentrations, otherwise return `None`.</span>

<span class="sd">                  - &#39;bound&#39;: if IC50 is out of range of concentrations,</span>
<span class="sd">                    return upper or lower measured concentration depending</span>
<span class="sd">                    on if IC50 is above or below range of concentrations.</span>
<span class="sd">                    Assumes infectivity decreases with concentration.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number giving IC50 or `None` (depending on value of `method`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">icXX</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span></div>


<div class="viewcode-block" id="HillCurve.ic50_stdev">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.ic50_stdev">[docs]</a>
    <span class="k">def</span> <span class="nf">ic50_stdev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get standard deviation of fit IC50 parameter.</span>

<span class="sd">        Calculated just from estimated standard deviation on `midpoint`.</span>
<span class="sd">        Note if you have replicates, we recommend fitting separately</span>
<span class="sd">        and calculating standard error from those fits rather than</span>
<span class="sd">        using this value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A number giving the standard deviation, or `None` if cannot</span>
<span class="sd">            be estimated or if IC50 is at bound.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ic50</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ic50</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ic50</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">midpoint_stdev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_stdev</span><span class="p">[</span><span class="s2">&quot;midpoint&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">midpoint_stdev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">midpoint_stdev</span> <span class="o">*</span> <span class="n">ic50</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span></div>


<div class="viewcode-block" id="HillCurve.icXX_bound">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.icXX_bound">[docs]</a>
    <span class="k">def</span> <span class="nf">icXX_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fracneut</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like :meth:`HillCurve.ic50_bound` for arbitrary frac neutralized.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">icXX</span><span class="p">(</span><span class="n">fracneut</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;interpolate&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;interpolated&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">icXX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">icXX</span><span class="p">(</span><span class="n">fracneut</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bound&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">icXX</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="s2">&quot;upper&quot;</span>
            <span class="k">elif</span> <span class="n">icXX</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="s2">&quot;lower&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;icXX not bound for </span><span class="si">{</span><span class="n">fracneut</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="HillCurve.ic50_bound">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.ic50_bound">[docs]</a>
    <span class="k">def</span> <span class="nf">ic50_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is IC50 &#39;interpolated&#39;, or an &#39;upper&#39; or &#39;lower&#39; bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">icXX_bound</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span></div>


<div class="viewcode-block" id="HillCurve.icXX_str">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.icXX_str">[docs]</a>
    <span class="k">def</span> <span class="nf">icXX_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fracneut</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like :meth:`HillCurve.ic50_str` for arbitrary frac neutralized.&quot;&quot;&quot;</span>
        <span class="n">icXX</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="s2">:.</span><span class="si">{</span><span class="n">precision</span><span class="si">}</span><span class="s2">g</span><span class="se">}}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">icXX</span><span class="p">(</span><span class="n">fracneut</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bound&quot;</span><span class="p">))</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;interpolated&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">}[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">icXX_bound</span><span class="p">(</span><span class="n">fracneut</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">icXX</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="HillCurve.ic50_str">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.ic50_str">[docs]</a>
    <span class="k">def</span> <span class="nf">ic50_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;IC50 as string indicating upper / lower bounds with &gt; or &lt;.</span>

<span class="sd">        Args:</span>
<span class="sd">            Number of significant digits in returned string.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">icXX_str</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span></div>


<div class="viewcode-block" id="HillCurve.fracinfectivity">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.fracinfectivity">[docs]</a>
    <span class="k">def</span> <span class="nf">fracinfectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fraction infectivity at `c` for fitted parameters.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
            <span class="n">c</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="HillCurve.evaluate">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.evaluate">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">infectivity_or_neutralized</span><span class="o">=</span><span class="s2">&quot;infectivity&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`f\left(c\right) = b + \frac{t-b}{1+\left(c/m\right)^s}`.</span>

<span class="sd">        If `infectivity_or_neutralized` is &#39;neutralized&#39; rather than</span>
<span class="sd">        &#39;infectivity&#39;, instead return</span>
<span class="sd">        :math:`f\left(c\right) = t + \frac{b-t}{1+\left(c/m\right)^s}`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s2">&quot;infectivity&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="n">m</span><span class="p">)</span> <span class="o">**</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s2">&quot;neutralized&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="n">m</span><span class="p">)</span> <span class="o">**</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid </span><span class="si">{</span><span class="n">infectivity_or_neutralized</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_evaluate_log</span><span class="p">(</span><span class="n">logc</span><span class="p">,</span> <span class="n">logm</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">infectivity_or_neutralized</span><span class="o">=</span><span class="s2">&quot;infectivity&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like :class:`HillCurve.evaluate` but on log concentration scale.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s2">&quot;infectivity&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">logc</span> <span class="o">-</span> <span class="n">logm</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s2">&quot;neutralized&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">logc</span> <span class="o">-</span> <span class="n">logm</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid </span><span class="si">{</span><span class="n">infectivity_or_neutralized</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="HillCurve.plot">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">concentrations</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;concentration&quot;</span><span class="p">,</span>
        <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;fraction infectivity&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
        <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
        <span class="n">markersize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
        <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
        <span class="n">yticklocs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">draw_in_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the neutralization curve.</span>

<span class="sd">        Args:</span>
<span class="sd">            `concentrations`</span>
<span class="sd">                Concentrations to plot, same meaning as for</span>
<span class="sd">                :meth:`HillCurve.dataframe`.</span>
<span class="sd">            `ax` (`None` or matplotlib axes.Axes object)</span>
<span class="sd">                Use to plot on an existing axis. If using an existing</span>
<span class="sd">                axis, do **not** re-scale the axis limits to the data.</span>
<span class="sd">            `xlabel` (str or `None`)</span>
<span class="sd">                Label for x-axis.</span>
<span class="sd">            `ylabel` (str or `None`)</span>
<span class="sd">                Label for y-axis.</span>
<span class="sd">            `color` (str)</span>
<span class="sd">                Color of line and point.</span>
<span class="sd">            `marker` (str)</span>
<span class="sd">                Marker shape: https://matplotlib.org/api/markers_api.html</span>
<span class="sd">            `markersize` (float)</span>
<span class="sd">                Size of point marker.</span>
<span class="sd">            `linewidth` (float)</span>
<span class="sd">                Width of line.</span>
<span class="sd">            `linestyle` (str)</span>
<span class="sd">                Line style.</span>
<span class="sd">            `yticklocs` (`None` or list)</span>
<span class="sd">                Exact locations to place yticks; `None` means auto-locate.</span>
<span class="sd">            `draw_in_bounds` (bool)</span>
<span class="sd">                By default, the plotted curve extends a bit outside the actual</span>
<span class="sd">                data points on both sides. If this is set to `True`, then the</span>
<span class="sd">                plotted curve stops at the bounds of the data points.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The 2-tuple `(fig, ax)` giving the matplotlib figure and axis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataframe</span><span class="p">(</span><span class="n">concentrations</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="mi">0</span> <span class="k">if</span> <span class="n">draw_in_bounds</span> <span class="k">else</span> <span class="mf">0.1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">check_ybounds</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ylowerbound</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.05</span>
            <span class="n">yupperbound</span> <span class="o">=</span> <span class="mf">1.05</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">)</span>
            <span class="n">check_ybounds</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="s2">&quot;concentration&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fit&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="s2">&quot;concentration&quot;</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="s2">&quot;measurement&quot;</span><span class="p">,</span>
            <span class="n">yerr</span><span class="o">=</span><span class="s2">&quot;stderr&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">fmt</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="n">markersize</span><span class="p">,</span>
            <span class="n">capsize</span><span class="o">=</span><span class="n">markersize</span> <span class="o">/</span> <span class="mf">1.5</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">minorticks_off</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">yticklocs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">yticklocs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_ybounds</span><span class="p">:</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ylowerbound</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ymax</span><span class="p">,</span> <span class="n">yupperbound</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="HillCurve.dataframe">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.dataframe">[docs]</a>
    <span class="k">def</span> <span class="nf">dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">concentrations</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get data frame with curve data for plotting.</span>

<span class="sd">        Useful if you want to get both the points and the fit</span>
<span class="sd">        curve to plot.</span>

<span class="sd">        Args:</span>
<span class="sd">            `concentrations` (array-like or &#39;auto&#39; or &#39;measured&#39;)</span>
<span class="sd">                Concentrations for which we compute the fit values.</span>
<span class="sd">                If &#39;auto&#39; the automatically computed from data</span>
<span class="sd">                range using :func:`concentrationRange`. If</span>
<span class="sd">                &#39;measured&#39; then only include measured values.</span>
<span class="sd">            `extend` (float)</span>
<span class="sd">                The value passed to :func:`concentrationRange` if `concentrations`</span>
<span class="sd">                is &#39;auto&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A pandas DataFrame with the following columns:</span>

<span class="sd">              - &#39;concentration&#39;: concentration</span>
<span class="sd">              - &#39;fit&#39;: curve fit value at this point</span>
<span class="sd">              - &#39;measurement&#39;: value of measurement at this point,</span>
<span class="sd">                or numpy.nan if no measurement here.</span>
<span class="sd">              - &#39;stderr&#39;: standard error of measurement if provided.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">concentrations</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">concentrations</span> <span class="o">=</span> <span class="n">concentrationRange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">extend</span><span class="o">=</span><span class="n">extend</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">concentrations</span> <span class="o">==</span> <span class="s2">&quot;measured&quot;</span><span class="p">:</span>
            <span class="n">concentrations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">concentrations</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">,</span> <span class="n">concentrations</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">concentrations</span><span class="p">)</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stderr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stderr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)]</span>
            <span class="p">)</span>

        <span class="n">fit</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fracinfectivity</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">concentrations</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
                <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">(</span><span class="s2">&quot;concentration&quot;</span><span class="p">,</span> <span class="n">concentrations</span><span class="p">),</span>
                        <span class="p">(</span><span class="s2">&quot;measurement&quot;</span><span class="p">,</span> <span class="n">points</span><span class="p">),</span>
                        <span class="p">(</span><span class="s2">&quot;fit&quot;</span><span class="p">,</span> <span class="n">fit</span><span class="p">),</span>
                        <span class="p">(</span><span class="s2">&quot;stderr&quot;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">),</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;concentration&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="concentrationRange">
<a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.concentrationRange">[docs]</a>
<span class="k">def</span> <span class="nf">concentrationRange</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Logarithmically spaced concentrations for plotting.</span>

<span class="sd">    Useful if you want to plot a curve by fitting values to densely</span>
<span class="sd">    sampled points and need the concentrations at which to compute</span>
<span class="sd">    these points.</span>

<span class="sd">    Args:</span>
<span class="sd">        `bottom` (float)</span>
<span class="sd">            Lowest concentration.</span>
<span class="sd">        `top` (float)</span>
<span class="sd">            Highest concentration.</span>
<span class="sd">        `npoints` (int)</span>
<span class="sd">            Number of points.</span>
<span class="sd">        `extend` (float)</span>
<span class="sd">            After transforming to log space, extend range of points</span>
<span class="sd">            by this much below and above `bottom` and `top`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy array of `npoints` concentrations.</span>

<span class="sd">    &gt;&gt;&gt; numpy.allclose(concentrationRange(0.1, 100, 10, extend=0),</span>
<span class="sd">    ...                [0.1, 0.22, 0.46, 1, 2.15, 4.64, 10, 21.54, 46.42, 100],</span>
<span class="sd">    ...                atol=1e-2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(concentrationRange(0.1, 100, 10),</span>
<span class="sd">    ...                [0.05, 0.13, 0.32, 0.79, 2.00, 5.01,</span>
<span class="sd">    ...                 12.59, 31.62, 79.43, 199.53],</span>
<span class="sd">    ...                atol=1e-2)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">top</span> <span class="o">&lt;=</span> <span class="n">bottom</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bottom</span><span class="si">=}</span><span class="s2"> must be less than </span><span class="si">{</span><span class="n">top</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bottom</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;{bottom=} must be greater than zero&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">extend</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;{extend=} must be &gt;= 0&quot;</span><span class="p">)</span>

    <span class="n">logbottom</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span>
    <span class="n">logtop</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
    <span class="n">logrange</span> <span class="o">=</span> <span class="n">logtop</span> <span class="o">-</span> <span class="n">logbottom</span>
    <span class="k">assert</span> <span class="n">logrange</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="n">logbottom</span> <span class="o">-</span> <span class="n">logrange</span> <span class="o">*</span> <span class="n">extend</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">logtop</span> <span class="o">+</span> <span class="n">logrange</span> <span class="o">*</span> <span class="n">extend</span>

    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>

    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/BloomLogo.jpg" alt="Logo" />
    
    <h1 class="logo logo-name">neutcurve</h1>
    
  </a>
</p>



<p class="blurb">Fit and plot neutralization curves</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=jbloomlab&repo=neutcurve&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">neutcurve documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hillcurve_example.html">Hill-curve neutralization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../curvefits_example.html">Fitting curves to real data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../constrain_params_range.html">Constrain fit parameters to a range of reasonable values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../combine_curvefits.html">Combining <code class="docutils literal notranslate"><span class="pre">CurveFits</span></code> objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test_curves.html">Test curve fitting on some real data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../neutcurve.html">neutcurve package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../package_index.html">package index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../acknowledgments.html">Acknowledgements</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2019--2024, Bloom lab.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    
    <a href="https://github.com/jbloomlab/neutcurve" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>