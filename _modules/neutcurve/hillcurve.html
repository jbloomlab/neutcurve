
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>neutcurve.hillcurve &#8212; neutcurve 0.5.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for neutcurve.hillcurve</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">==================</span>
<span class="sd">hillcurve</span>
<span class="sd">==================</span>

<span class="sd">Defines :class:`HillCurve` for fitting neutralization curves.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">scipy.optimize</span>


<div class="viewcode-block" id="HillCurve"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve">[docs]</a><span class="k">class</span> <span class="nc">HillCurve</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A fitted Hill curve, optionally with free baselines.</span>

<span class="sd">    Fits :math:`f\left(c\right) = b + \frac{t - b}{1 + \left(c/m\right)^s}`</span>
<span class="sd">    where :math:`f\left(c\right)` is the fraction infectivity remaining</span>
<span class="sd">    at concentration :math:`c`, :math:`m` is the midpoint</span>
<span class="sd">    of the neutralization curve, :math:`t` is the top</span>
<span class="sd">    value (e.g., 1), :math:`b` is the bottom value (e.g., 0),</span>
<span class="sd">    and :math:`s` is the slope of the curve. Because</span>
<span class="sd">    :math:`f\left(c\right)` is the fraction infectivity remaining, we expect</span>
<span class="sd">    :math:`f\left(c\right)` to get smaller as :math:`c` gets larger.</span>
<span class="sd">    This should lead us to fit :math:`s &gt; 0`.</span>

<span class="sd">    When :math:`t = 1` and :math:`b = 0`, this equation is identical to the</span>
<span class="sd">    `Hill curve &lt;https://en.wikipedia.org/wiki/Hill_equation_(biochemistry)&gt;`_,</span>
<span class="sd">    except that we are calculating the fraction **unbound** rather than</span>
<span class="sd">    the fraction bound.</span>

<span class="sd">    You may want to fit the fraction neutralized rather than the fraction</span>
<span class="sd">    infectivity. In that case, set `infectivity_or_neutralized=&#39;neutralized&#39;</span>
<span class="sd">    and then the equation that is fit will</span>
<span class="sd">    be :math:`f\left(c\right) = t + \frac{b - t}{1 + \left(c/m\right)^s}`,</span>
<span class="sd">    which means that `f\left(c\right)` gets larger rather than smaller</span>
<span class="sd">    as :math:`c` increases.</span>

<span class="sd">    Args:</span>
<span class="sd">        `cs` (array-like)</span>
<span class="sd">            Concentrations of antibody / serum.</span>
<span class="sd">        `fs` (array-like)</span>
<span class="sd">            Fraction infectivity remaining at each concentration.</span>
<span class="sd">        `infectivity_or_neutralized` ({&#39;infectivity&#39;, &#39;neutralized&#39;})</span>
<span class="sd">            Fit the fraction infectivity (:math:`f\left(c\right)` decreases as</span>
<span class="sd">            :math:`c` increases) or neutralized (:math:`f\left(c\right)`</span>
<span class="sd">            increases as :math:`c` increases). See equations above.</span>
<span class="sd">        `fs_stderr` (`None` or array-like)</span>
<span class="sd">            If not `None`, standard errors on `fs`.</span>
<span class="sd">        `fixbottom` (bool or a float)</span>
<span class="sd">            If `True`, fix bottom of curve to to this value; otherwise fit.</span>
<span class="sd">        `fixtop` (`False` or a float)</span>
<span class="sd">            If `True`, fix top of curve to this value; otherwise fit.</span>
<span class="sd">        `fitlogc` (bool)</span>
<span class="sd">            Do we do the actual fitting on the concentrations or log</span>
<span class="sd">            concentrations? Gives equivalent results in principle, but</span>
<span class="sd">            fitting to log concentrations may be more efficient in pratice.</span>
<span class="sd">        `use_stderr_for_fit` (bool)</span>
<span class="sd">            Do we use `fs_stderr` for the fitting, or just for plotting?</span>
<span class="sd">            Usually it is a good idea to set to `False` and **not** use</span>
<span class="sd">            for fitting if you only have a few replicates, and the standard</span>
<span class="sd">            error is often not that accurate and so will weight some</span>
<span class="sd">            points much more than others in a way that may not be</span>
<span class="sd">            justified.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        `cs` (numpy array)</span>
<span class="sd">            Concentrations, sorted from low to high.</span>
<span class="sd">        `fs` (numpy array)</span>
<span class="sd">            Fraction infectivity, ordered to match sorted concentrations.</span>
<span class="sd">        `fs_stderr` (numpy array or `None`)</span>
<span class="sd">            Standard errors on `fs`.</span>
<span class="sd">        `bottom` (float)</span>
<span class="sd">            Bottom of curve, :math:`b` in equation above.</span>
<span class="sd">        `top` (float)</span>
<span class="sd">            Top of curve, :math:`t` in equation above.</span>
<span class="sd">        `midpoint` (float)</span>
<span class="sd">            Midpoint of curve, :math:`m` in equation above. Note</span>
<span class="sd">            that the midpoint may **not** be the same as the :meth:`ic50`</span>
<span class="sd">            if :math:`t \ne 1` or :math:`b \ne 0`.</span>
<span class="sd">        `slope` (float)</span>
<span class="sd">            Hill slope of curve, :math:`s` in equation above.</span>

<span class="sd">    Use the :meth:`ic50` method to get the fitted IC50.</span>

<span class="sd">    Here are some examples. First, we import the necessary modules:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; import numpy</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; from neutcurve import HillCurve</span>
<span class="sd">        &gt;&gt;&gt; from neutcurve.colorschemes import CBPALETTE</span>

<span class="sd">    Now simulate some data:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; m = 0.03</span>
<span class="sd">        &gt;&gt;&gt; s = 1.9</span>
<span class="sd">        &gt;&gt;&gt; b = 0.1</span>
<span class="sd">        &gt;&gt;&gt; t = 1.0</span>
<span class="sd">        &gt;&gt;&gt; cs = [0.002 * 2**x for x in range(9)]</span>
<span class="sd">        &gt;&gt;&gt; fs = [HillCurve.evaluate(c, m, s, b, t) for c in cs]</span>

<span class="sd">    Now fit to these data, and confirm that the fitted values</span>
<span class="sd">    are close to the ones used for the simulation:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut = HillCurve(cs, fs, fixbottom=False)</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut.midpoint, m)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut.slope, s, atol=1e-4)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut.top, t)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut.bottom, b)</span>
<span class="sd">        True</span>

<span class="sd">    Since we fit the curve to simulated data where the bottom was</span>
<span class="sd">    0.1 rather than 0, the midpoint and IC50 are different. Specifically,</span>
<span class="sd">    the IC50 is larger than the midpoint as you have to go past the midpoint</span>
<span class="sd">    to get down to 0.5 fraction infectivity:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut.ic50() &gt; neut.midpoint</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut.ic50(), 0.0337385586)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(0.5, neut.fracinfectivity(neut.ic50()))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; neut.fracinfectivity(neut.midpoint) &gt; 0.5</span>
<span class="sd">        True</span>

<span class="sd">    Now here is an example where we constrain both the top</span>
<span class="sd">    and the bottom (to 1 and 0, respectively) and fit</span>
<span class="sd">    the curve. Now the midpoint and IC50 are the same:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; b2 = 0</span>
<span class="sd">        &gt;&gt;&gt; t2 = 1</span>
<span class="sd">        &gt;&gt;&gt; fs2 = [HillCurve.evaluate(c, m, s, b2, t2) for c in cs]</span>
<span class="sd">        &gt;&gt;&gt; neut2 = HillCurve(cs, fs2)</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut2.midpoint, m)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut2.ic50(), m)</span>
<span class="sd">        True</span>

<span class="sd">    Now let&#39;s fit to concentrations that are all **less**</span>
<span class="sd">    than the midpoint, so that we never get to complete neutralization.</span>
<span class="sd">    The estimated IC50 is unreliable, and so will be returned as `None` unless</span>
<span class="sd">    we call :meth:`ic50` with `method` set to &#39;bound&#39;:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; cs3 = [1e-5 * 2**x for x in range(7)]</span>
<span class="sd">        &gt;&gt;&gt; (cs3[-1] &lt; m)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; fs3 = [HillCurve.evaluate(c, m, s, b2, t2) for c in cs3]</span>
<span class="sd">        &gt;&gt;&gt; neut3 = HillCurve(cs3, fs3)</span>
<span class="sd">        &gt;&gt;&gt; neut3.ic50() is None</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; numpy.allclose(neut3.ic50(method=&#39;bound&#39;), cs3[-1])</span>
<span class="sd">        True</span>

<span class="sd">    Note that we can determine if the IC50 is interpolated or an upper</span>
<span class="sd">    or lower bound using :meth:`ic50_bound`, and get a nice string</span>
<span class="sd">    using :meth:`ic50_str`:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut.ic50_bound()</span>
<span class="sd">        &#39;interpolated&#39;</span>
<span class="sd">        &gt;&gt;&gt; neut3.ic50_bound()</span>
<span class="sd">        &#39;lower&#39;</span>
<span class="sd">        &gt;&gt;&gt; neut.ic50_str()</span>
<span class="sd">        &#39;0.0337&#39;</span>
<span class="sd">        &gt;&gt;&gt; neut3.ic50_str()</span>
<span class="sd">        &#39;&gt;0.00064&#39;</span>

<span class="sd">    We can use the :meth:`dataframe` method to get the measured</span>
<span class="sd">    data and fit data at selected points. First, we do this</span>
<span class="sd">    just at measured points:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut.dataframe(&#39;measured&#39;).round(3)</span>
<span class="sd">           concentration  measurement    fit  stderr</span>
<span class="sd">        0          0.002        0.995  0.995     NaN</span>
<span class="sd">        1          0.004        0.981  0.981     NaN</span>
<span class="sd">        2          0.008        0.932  0.932     NaN</span>
<span class="sd">        3          0.016        0.791  0.791     NaN</span>
<span class="sd">        4          0.032        0.522  0.522     NaN</span>
<span class="sd">        5          0.064        0.272  0.272     NaN</span>
<span class="sd">        6          0.128        0.154  0.154     NaN</span>
<span class="sd">        7          0.256        0.115  0.115     NaN</span>
<span class="sd">        8          0.512        0.104  0.104     NaN</span>

<span class="sd">    Then we add in one more point:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut.dataframe([0.6]).round(3)</span>
<span class="sd">           concentration  measurement    fit  stderr</span>
<span class="sd">        0          0.002        0.995  0.995     NaN</span>
<span class="sd">        1          0.004        0.981  0.981     NaN</span>
<span class="sd">        2          0.008        0.932  0.932     NaN</span>
<span class="sd">        3          0.016        0.791  0.791     NaN</span>
<span class="sd">        4          0.032        0.522  0.522     NaN</span>
<span class="sd">        5          0.064        0.272  0.272     NaN</span>
<span class="sd">        6          0.128        0.154  0.154     NaN</span>
<span class="sd">        7          0.256        0.115  0.115     NaN</span>
<span class="sd">        8          0.512        0.104  0.104     NaN</span>
<span class="sd">        9          0.600          NaN  0.103     NaN</span>

<span class="sd">    In reality, you&#39;d typically just call :meth:`dataframe` with</span>
<span class="sd">    the default argument of &#39;auto&#39; to get a good range to plot.</span>
<span class="sd">    This is done if we call the :meth:`HillCurve.plot` method:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; fig, ax = neut.plot()</span>

<span class="sd">    Finally, we confirm that we get the same result regardless</span>
<span class="sd">    of whether we fit using the concentrations in linear or</span>
<span class="sd">    log space:</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">        &gt;&gt;&gt; neut_linear = HillCurve(cs, fs, fitlogc=False, fixbottom=False)</span>
<span class="sd">        &gt;&gt;&gt; all(numpy.allclose(getattr(neut, attr), getattr(neut_linear, attr))</span>
<span class="sd">        ...     for attr in [&#39;top&#39;, &#39;bottom&#39;, &#39;slope&#39;, &#39;midpoint&#39;])</span>
<span class="sd">        True</span>

<span class="sd">    Demonstrate :meth:`HillCurve.icXX`:</span>

<span class="sd">    &gt;&gt;&gt; neut.icXX(0.95) is None</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; neut.icXX_str(0.95)</span>
<span class="sd">    &#39;&gt;0.512&#39;</span>
<span class="sd">    &gt;&gt;&gt; neut.icXX_bound(0.95)</span>
<span class="sd">    &#39;lower&#39;</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(neut.icXX(0.95, method=&#39;bound&#39;), neut.cs[-1])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; &#39;{:.4f}&#39;.format(neut.icXX(0.8), 4)</span>
<span class="sd">    &#39;0.0896&#39;</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(0.2, neut.fracinfectivity(neut.icXX(0.8)))</span>
<span class="sd">    True</span>

<span class="sd">    Now fit with `infectivity_or_neutralized=&#39;neutralized&#39;`, which is useful</span>
<span class="sd">    when the signal **increases** rather than decreases with increasing</span>
<span class="sd">    concentration (as would be the case if measuring fraction bound rather</span>
<span class="sd">    than fraction infectivity).</span>

<span class="sd">    .. nbplot::</span>

<span class="sd">       &gt;&gt;&gt; neut_opp = HillCurve(cs, [1 - f for f in fs],</span>
<span class="sd">       ...                      fixtop=False, fixbottom=False,</span>
<span class="sd">       ...                      infectivity_or_neutralized=&#39;neutralized&#39;)</span>
<span class="sd">       &gt;&gt;&gt; numpy.allclose(neut_opp.top, 0.9)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; numpy.allclose(neut_opp.bottom, 0)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; numpy.allclose(neut_opp.midpoint, m)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; neut_opp.ic50() &lt; neut_opp.midpoint</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; fig, ax = neut_opp.plot(ylabel=&#39;fraction neutralized&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">cs</span><span class="p">,</span>
                 <span class="n">fs</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span>
                 <span class="n">infectivity_or_neutralized</span><span class="o">=</span><span class="s1">&#39;infectivity&#39;</span><span class="p">,</span>
                 <span class="n">fs_stderr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fixbottom</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">fixtop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">fitlogc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">use_stderr_for_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See main class docstring.&quot;&quot;&quot;</span>
        <span class="c1"># get data into arrays sorted by concentration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fs_stderr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fs_stderr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>

        <span class="k">if</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s1">&#39;infectivity&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.3</span> <span class="ow">and</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.7</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;`f` increases with concentration, consider &#39;</span>
                              <span class="s1">&#39;`infectivity_or_neutralized=&quot;neutralized&quot;&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s1">&#39;neutralized&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.7</span> <span class="ow">and</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.3</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;`f` decreases with concentration, consider &#39;</span>
                              <span class="s1">&#39;`infectivity_or_neutralized=&quot;infectivity&quot;&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid `infectivity_or_neutralized`&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span> <span class="o">=</span> <span class="n">infectivity_or_neutralized</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;concentrations in `cs` must all be &gt; 0&#39;</span><span class="p">)</span>

        <span class="c1"># first try to fit using curve_fit</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fit_tup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_curve</span><span class="p">(</span><span class="n">fixtop</span><span class="o">=</span><span class="n">fixtop</span><span class="p">,</span>
                                      <span class="n">fixbottom</span><span class="o">=</span><span class="n">fixbottom</span><span class="p">,</span>
                                      <span class="n">fitlogc</span><span class="o">=</span><span class="n">fitlogc</span><span class="p">,</span>
                                      <span class="n">use_stderr_for_fit</span><span class="o">=</span><span class="n">use_stderr_for_fit</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="c1"># curve_fit failed, try using minimize</span>
            <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;TNC&#39;</span><span class="p">,</span> <span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">,</span> <span class="s1">&#39;SLSQP&#39;</span><span class="p">]:</span>
                <span class="n">fit_tup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minimize_fit</span><span class="p">(</span>
                                    <span class="n">fixtop</span><span class="o">=</span><span class="n">fixtop</span><span class="p">,</span>
                                    <span class="n">fixbottom</span><span class="o">=</span><span class="n">fixbottom</span><span class="p">,</span>
                                    <span class="n">fitlogc</span><span class="o">=</span><span class="n">fitlogc</span><span class="p">,</span>
                                    <span class="n">use_stderr_for_fit</span><span class="o">=</span><span class="n">use_stderr_for_fit</span><span class="p">,</span>
                                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">fit_tup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fit failed:</span><span class="se">\n</span><span class="s2">cs=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="si">}</span><span class="se">\n</span><span class="s2">fs=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;midpoint&#39;</span><span class="p">,</span> <span class="s1">&#39;slope&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">]):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">fit_tup</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_fit_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">fixtop</span><span class="p">,</span> <span class="n">fixbottom</span><span class="p">,</span> <span class="n">fitlogc</span><span class="p">,</span> <span class="n">use_stderr_for_fit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit via curve_fit, and return `(midpoint, slope, bottom, top)`.&quot;&quot;&quot;</span>
        <span class="c1"># make initial guess for slope to have the right sign</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="mf">1.5</span>

        <span class="c1"># make initial guess for top and bottom</span>
        <span class="k">if</span> <span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`fixtop` is not `False` or a number&#39;</span><span class="p">)</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">fixtop</span>
        <span class="k">if</span> <span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`fixbottom` is not `False` or a number&#39;</span><span class="p">)</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">fixbottom</span>

        <span class="c1"># make initial guess for midpoint</span>
        <span class="c1"># if midpoint guess outside range, guess outside range by amount</span>
        <span class="c1"># equal to spacing of last two points</span>
        <span class="n">midval</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;infectivity&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                        <span class="s1">&#39;neutralized&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                        <span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&lt;=</span> <span class="n">midval</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;neutralized&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                        <span class="s1">&#39;infectivity&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                        <span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get first index where f crosses midpoint</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="c1"># set up function and initial guesses</span>
        <span class="k">if</span> <span class="n">fitlogc</span><span class="p">:</span>
            <span class="n">evalfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_log</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">evalfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span>

        <span class="k">if</span> <span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

        <span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span><span class="p">)</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span>
                <span class="n">f</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
                <span class="n">xdata</span><span class="o">=</span><span class="n">xdata</span><span class="p">,</span>
                <span class="n">ydata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                <span class="n">p0</span><span class="o">=</span><span class="n">initguess</span><span class="p">,</span>
                <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="k">if</span> <span class="n">use_stderr_for_fit</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">absolute_sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">maxfev</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">fitlogc</span><span class="p">:</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>

        <span class="n">midpoint</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_minimize_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">fixtop</span><span class="p">,</span> <span class="n">fixbottom</span><span class="p">,</span> <span class="n">fitlogc</span><span class="p">,</span> <span class="n">use_stderr_for_fit</span><span class="p">,</span>
                      <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit via minimization, return `(midpoint, slope, bottom, top)`.&quot;&quot;&quot;</span>
        <span class="c1"># make initial guess for slope to have the right sign</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="mf">1.5</span>

        <span class="c1"># make initial guess for top and bottom</span>
        <span class="k">if</span> <span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixtop</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`fixtop` is not `False` or a number&#39;</span><span class="p">)</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">fixtop</span>
        <span class="k">if</span> <span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixbottom</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`fixbottom` is not `False` or a number&#39;</span><span class="p">)</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">fixbottom</span>

        <span class="c1"># make initial guess for midpoint</span>
        <span class="c1"># if midpoint guess outside range, guess outside range by amount</span>
        <span class="c1"># equal to spacing of last two points</span>
        <span class="n">midval</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;infectivity&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                        <span class="s1">&#39;neutralized&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                        <span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&lt;=</span> <span class="n">midval</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;neutralized&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                        <span class="s1">&#39;infectivity&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                        <span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get first index where f crosses midpoint</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">midval</span><span class="p">)</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="c1"># set up function and initial guesses</span>
        <span class="k">if</span> <span class="n">fitlogc</span><span class="p">:</span>
            <span class="n">evalfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_log</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">)</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">evalfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span> <span class="o">+</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">top</span><span class="p">]</span>
            <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">bottom</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">]</span>
            <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="n">top</span><span class="p">))</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initguess</span> <span class="o">=</span> <span class="p">[</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">evalfunc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">min_func</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Evaluate to zero when perfect fit.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">use_stderr_for_fit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">func</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">func</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">initguess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initguess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">min_func</span><span class="p">,</span>
                                      <span class="n">initguess</span><span class="p">,</span>
                                      <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                                      <span class="n">method</span><span class="o">=</span><span class="s1">&#39;TNC&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">fitlogc</span><span class="p">:</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">midpoint</span><span class="p">)</span>

        <span class="n">midpoint</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">fixbottom</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">fixtop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">midpoint</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">)</span>

<div class="viewcode-block" id="HillCurve.icXX"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.icXX">[docs]</a>    <span class="k">def</span> <span class="nf">icXX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fracneut</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generalizes :meth:`HillCurve.ic50` to arbitrary frac neutralized.</span>

<span class="sd">        For instance, set `fracneut` to 0.95 if you want the IC95, the</span>
<span class="sd">        concentration where 95% is neutralized.</span>

<span class="sd">        Args:</span>
<span class="sd">            `fracneut` (float)</span>
<span class="sd">                Compute concentration at which `fracneut` of the virus</span>
<span class="sd">                is expected to be neutralized. Note that this is the</span>
<span class="sd">                expected fraction **neutralized**, not the fraction</span>
<span class="sd">                infectivity.</span>
<span class="sd">            `method` (str)</span>
<span class="sd">                Can have following values:</span>

<span class="sd">                  - &#39;interpolate&#39;: only return a number for ICXX if it</span>
<span class="sd">                    is in range of concentrations, otherwise return `None`.</span>

<span class="sd">                  - &#39;bound&#39;: if ICXX is out of range of concentrations,</span>
<span class="sd">                    return upper or lower measured concentration depending</span>
<span class="sd">                    on if ICXX is above or below range of concentrations.</span>
<span class="sd">                    Assumes infectivity decreases with concentration.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number giving ICXX or `None` (depending on value of `method`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fracinf</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">fracneut</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">&lt;</span> <span class="n">fracinf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&lt;</span> <span class="n">fracinf</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">&gt;=</span> <span class="n">fracinf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&gt;=</span> <span class="n">fracinf</span><span class="p">:</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">icXX</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span> <span class="o">*</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">-</span> <span class="n">fracinf</span><span class="p">)</span> <span class="o">/</span>
                    <span class="p">(</span><span class="n">fracinf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">icXX</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">icXX</span>
            <span class="k">elif</span> <span class="n">icXX</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="s1">&#39;lower&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bound</span> <span class="o">=</span> <span class="s1">&#39;upper&#39;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bound&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bound</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">bound</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid `bound` </span><span class="si">{</span><span class="n">bound</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;interpolate&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid `method` of </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HillCurve.ic50"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.ic50">[docs]</a>    <span class="k">def</span> <span class="nf">ic50</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;IC50 value.</span>

<span class="sd">        Concentration where infectivity remaining is 0.5. Equals</span>
<span class="sd">        `midpoint` if and only if `top = 1` and `bottom = 0`. Calculated</span>
<span class="sd">        from :math:`0.5 = b + \frac{t - b}{1 + (ic50/m)^s}`, which solves to</span>
<span class="sd">        :math:`ic50 = m \times \left(\frac{t - 0.5}{0.5 - b}\right)^{1/s}`</span>

<span class="sd">        Args:</span>
<span class="sd">            `method` (str)</span>
<span class="sd">                Can have following values:</span>

<span class="sd">                  - &#39;interpolate&#39;: only return a number for IC50 if it</span>
<span class="sd">                    is in range of concentrations, otherwise return `None`.</span>

<span class="sd">                  - &#39;bound&#39;: if IC50 is out of range of concentrations,</span>
<span class="sd">                    return upper or lower measured concentration depending</span>
<span class="sd">                    on if IC50 is above or below range of concentrations.</span>
<span class="sd">                    Assumes infectivity decreases with concentration.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number giving IC50 or `None` (depending on value of `method`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">icXX</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span></div>

<div class="viewcode-block" id="HillCurve.icXX_bound"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.icXX_bound">[docs]</a>    <span class="k">def</span> <span class="nf">icXX_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fracneut</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like :meth:`HillCurve.ic50_bound` for arbitrary frac neutralized.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">icXX</span><span class="p">(</span><span class="n">fracneut</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;interpolated&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">icXX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">icXX</span><span class="p">(</span><span class="n">fracneut</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bound&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">icXX</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="s1">&#39;upper&#39;</span>
            <span class="k">elif</span> <span class="n">icXX</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="s1">&#39;lower&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;icXX not bound for </span><span class="si">{</span><span class="n">fracneut</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HillCurve.ic50_bound"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.ic50_bound">[docs]</a>    <span class="k">def</span> <span class="nf">ic50_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Is IC50 &#39;interpolated&#39;, or an &#39;upper&#39; or &#39;lower&#39; bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">icXX_bound</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span></div>

<div class="viewcode-block" id="HillCurve.icXX_str"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.icXX_str">[docs]</a>    <span class="k">def</span> <span class="nf">icXX_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fracneut</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like :meth:`HillCurve.ic50_str` for arbitrary frac neutralized.&quot;&quot;&quot;</span>
        <span class="n">icXX</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="s2">:.</span><span class="si">{</span><span class="n">precision</span><span class="si">}</span><span class="s2">g</span><span class="se">}}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">icXX</span><span class="p">(</span><span class="n">fracneut</span><span class="p">,</span>
                                                      <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bound&#39;</span><span class="p">))</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;interpolated&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;upper&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;lower&#39;</span><span class="p">:</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">icXX_bound</span><span class="p">(</span><span class="n">fracneut</span><span class="p">)]</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">icXX</span><span class="si">}</span><span class="s2">&quot;</span></div>

<div class="viewcode-block" id="HillCurve.ic50_str"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.ic50_str">[docs]</a>    <span class="k">def</span> <span class="nf">ic50_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;IC50 as string indicating upper / lower bounds with &gt; or &lt;.</span>

<span class="sd">        Args:</span>
<span class="sd">            Number of significant digits in returned string.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">icXX_str</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span></div>

<div class="viewcode-block" id="HillCurve.fracinfectivity"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.fracinfectivity">[docs]</a>    <span class="k">def</span> <span class="nf">fracinfectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fraction infectivity at `c` for fitted parameters.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_infectivity_or_neutralized</span><span class="p">)</span></div>

<div class="viewcode-block" id="HillCurve.evaluate"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.evaluate">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                 <span class="n">infectivity_or_neutralized</span><span class="o">=</span><span class="s1">&#39;infectivity&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`f\left(c\right) = b + \frac{t-b}{1+\left(c/m\right)^s}`.</span>

<span class="sd">        If `infectivity_or_neutralized` is &#39;neutralized&#39; rather than</span>
<span class="sd">        &#39;infectivity&#39;, instead return</span>
<span class="sd">        :math:`f\left(c\right) = t + \frac{b-t}{1+\left(c/m\right)^s}`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s1">&#39;infectivity&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="n">m</span><span class="p">)</span><span class="o">**</span><span class="n">s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s1">&#39;neutralized&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="n">m</span><span class="p">)</span><span class="o">**</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid `infectivity_or_neutralized`&#39;</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_evaluate_log</span><span class="p">(</span><span class="n">logc</span><span class="p">,</span> <span class="n">logm</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                      <span class="n">infectivity_or_neutralized</span><span class="o">=</span><span class="s1">&#39;infectivity&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like :class:`HillCurve.evaluate` but on log concentration scale.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s1">&#39;infectivity&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">logc</span> <span class="o">-</span> <span class="n">logm</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">infectivity_or_neutralized</span> <span class="o">==</span> <span class="s1">&#39;neutralized&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="n">logc</span> <span class="o">-</span> <span class="n">logm</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid `infectivity_or_neutralized`&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="HillCurve.plot"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="o">*</span><span class="p">,</span>
             <span class="n">concentrations</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
             <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;concentration&#39;</span><span class="p">,</span>
             <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;fraction infectivity&#39;</span><span class="p">,</span>
             <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span>
             <span class="n">markersize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span>
             <span class="n">yticklocs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the neutralization curve.</span>

<span class="sd">        Args:</span>
<span class="sd">            `concentrations`</span>
<span class="sd">                Concentrations to plot, same meaning as for</span>
<span class="sd">                :meth:`HillCurve.dataframe`.</span>
<span class="sd">            `ax` (`None` or matplotlib axes.Axes object)</span>
<span class="sd">                Use to plot on an existing axis. If using an existing</span>
<span class="sd">                axis, do **not** re-scale the axis limits to the data.</span>
<span class="sd">            `xlabel` (str or `None`)</span>
<span class="sd">                Label for x-axis.</span>
<span class="sd">            `ylabel` (str or `None`)</span>
<span class="sd">                Label for y-axis.</span>
<span class="sd">            `color` (str)</span>
<span class="sd">                Color of line and point.</span>
<span class="sd">            `marker` (str)</span>
<span class="sd">                Marker shape: https://matplotlib.org/api/markers_api.html</span>
<span class="sd">            `markersize` (float)</span>
<span class="sd">                Size of point marker.</span>
<span class="sd">            `linewidth` (float)</span>
<span class="sd">                Width of line.</span>
<span class="sd">            `linestyle` (str)</span>
<span class="sd">                Line style.</span>
<span class="sd">            `yticklocs` (`None` or list)</span>
<span class="sd">                Exact locations to place yticks; `None` means auto-locate.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The 2-tuple `(fig, ax)` giving the matplotlib figure and axis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataframe</span><span class="p">(</span><span class="n">concentrations</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">check_ybounds</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ylowerbound</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.05</span>
            <span class="n">yupperbound</span> <span class="o">=</span> <span class="mf">1.05</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span>
            <span class="n">check_ybounds</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;concentration&#39;</span><span class="p">,</span>
                <span class="s1">&#39;fit&#39;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s1">&#39;concentration&#39;</span><span class="p">,</span>
                    <span class="n">y</span><span class="o">=</span><span class="s1">&#39;measurement&#39;</span><span class="p">,</span>
                    <span class="n">yerr</span><span class="o">=</span><span class="s1">&#39;stderr&#39;</span><span class="p">,</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">fmt</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                    <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                    <span class="n">markersize</span><span class="o">=</span><span class="n">markersize</span><span class="p">,</span>
                    <span class="n">capsize</span><span class="o">=</span><span class="n">markersize</span> <span class="o">/</span> <span class="mf">1.5</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">minorticks_off</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">yticklocs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">yticklocs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_ybounds</span><span class="p">:</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ylowerbound</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ymax</span><span class="p">,</span> <span class="n">yupperbound</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="HillCurve.dataframe"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.HillCurve.dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">concentrations</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get data frame with curve data for plotting.</span>

<span class="sd">        Useful if you want to get both the points and the fit</span>
<span class="sd">        curve to plot.</span>

<span class="sd">        Args:</span>
<span class="sd">            `concentrations` (array-like or &#39;auto&#39; or &#39;measured&#39;)</span>
<span class="sd">                Concentrations for which we compute the fit values.</span>
<span class="sd">                If &#39;auto&#39; the automatically computed from data</span>
<span class="sd">                range using :func:`concentrationRange`. If</span>
<span class="sd">                &#39;measured&#39; then only include measured values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A pandas DataFrame with the following columns:</span>

<span class="sd">              - &#39;concentration&#39;: concentration</span>
<span class="sd">              - &#39;fit&#39;: curve fit value at this point</span>
<span class="sd">              - &#39;measurement&#39;: value of measurement at this point,</span>
<span class="sd">                or numpy.nan if no measurement here.</span>
<span class="sd">              - &#39;stderr&#39;: standard error of measurement if provided.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">concentrations</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">concentrations</span> <span class="o">=</span> <span class="n">concentrationRange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">concentrations</span> <span class="o">==</span> <span class="s1">&#39;measured&#39;</span><span class="p">:</span>
            <span class="n">concentrations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">concentrations</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">cs</span><span class="p">,</span> <span class="n">concentrations</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">concentrations</span><span class="p">)</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span>
                                    <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                                    <span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stderr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stderr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_stderr</span><span class="p">,</span>
                                        <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fs</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                                        <span class="p">])</span>

        <span class="n">fit</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fracinfectivity</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">concentrations</span><span class="p">])</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
                    <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span>
                        <span class="p">[(</span><span class="s1">&#39;concentration&#39;</span><span class="p">,</span> <span class="n">concentrations</span><span class="p">),</span>
                         <span class="p">(</span><span class="s1">&#39;measurement&#39;</span><span class="p">,</span> <span class="n">points</span><span class="p">),</span>
                         <span class="p">(</span><span class="s1">&#39;fit&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="p">),</span>
                         <span class="p">(</span><span class="s1">&#39;stderr&#39;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">),</span>
                         <span class="p">])</span>
                    <span class="p">)</span>
                <span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;concentration&#39;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span></div></div>


<div class="viewcode-block" id="concentrationRange"><a class="viewcode-back" href="../../neutcurve.hillcurve.html#neutcurve.hillcurve.concentrationRange">[docs]</a><span class="k">def</span> <span class="nf">concentrationRange</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Logarithmically spaced concentrations for plotting.</span>

<span class="sd">    Useful if you want to plot a curve by fitting values to densely</span>
<span class="sd">    sampled points and need the concentrations at which to compute</span>
<span class="sd">    these points.</span>

<span class="sd">    Args:</span>
<span class="sd">        `bottom` (float)</span>
<span class="sd">            Lowest concentration.</span>
<span class="sd">        `top` (float)</span>
<span class="sd">            Highest concentration.</span>
<span class="sd">        `npoints` (int)</span>
<span class="sd">            Number of points.</span>
<span class="sd">        `extend` (float)</span>
<span class="sd">            After transforming to log space, extend range of points</span>
<span class="sd">            by this much below and above `bottom` and `top`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy array of `npoints` concentrations.</span>

<span class="sd">    &gt;&gt;&gt; numpy.allclose(concentrationRange(0.1, 100, 10, extend=0),</span>
<span class="sd">    ...                [0.1, 0.22, 0.46, 1, 2.15, 4.64, 10, 21.54, 46.42, 100],</span>
<span class="sd">    ...                atol=1e-2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(concentrationRange(0.1, 100, 10),</span>
<span class="sd">    ...                [0.05, 0.13, 0.32, 0.79, 2.00, 5.01,</span>
<span class="sd">    ...                 12.59, 31.62, 79.43, 199.53],</span>
<span class="sd">    ...                atol=1e-2)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">top</span> <span class="o">&lt;=</span> <span class="n">bottom</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`bottom` must be less than `top`&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bottom</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`bottom` must be greater than zero&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">extend</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`extend` must be &gt;= 0&#39;</span><span class="p">)</span>

    <span class="n">logbottom</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span>
    <span class="n">logtop</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
    <span class="n">logrange</span> <span class="o">=</span> <span class="n">logtop</span> <span class="o">-</span> <span class="n">logbottom</span>
    <span class="k">assert</span> <span class="n">logrange</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="n">logbottom</span> <span class="o">-</span> <span class="n">logrange</span> <span class="o">*</span> <span class="n">extend</span>
    <span class="n">top</span> <span class="o">=</span> <span class="n">logtop</span> <span class="o">+</span> <span class="n">logrange</span> <span class="o">*</span> <span class="n">extend</span>

    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/BloomLogo.jpg" alt="Logo"/>
    
    <h1 class="logo logo-name">neutcurve</h1>
    
  </a>
</p>



<p class="blurb">Fit and plot neutralization curves</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=jbloomlab&repo=neutcurve&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/jbloomlab/neutcurve">
    <img
        alt="https://secure.travis-ci.org/jbloomlab/neutcurve.svg?branch=master"
        src="https://secure.travis-ci.org/jbloomlab/neutcurve.svg?branch=master"
    />
</a>
</p>


<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">neutcurve documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hillcurve_example.html">Hill-curve neutralization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../curvefits_example.html">Fitting curves to real data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../raw_examples.html">Raw data from plate reader</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../neutcurve.html">neutcurve package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../package_index.html">package index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../acknowledgments.html">Acknowledgements</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019--2020, Bloom lab.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/jbloomlab/neutcurve" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>